// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package frc.robot.subsystems;

import frc.robot.RobotContainer;
import jdk.jfr.Enabled;
//import frc.robot.commands.*;
//import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.AnalogGyro;
//import com.analog.adis16470.frc.ADIS16470_IMU;
//import com.analog.adis16470.frc.ADIS16470_IMU.ADIS16470CalibrationTime;
//import com.analog.adis16470.frc.ADIS16470_IMU.IMUAxis;

import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
//import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.RobotState;
//import edu.wpi.first.wpilibj.SpeedController;
//import edu.wpi.first.wpilibj.Talon;
//import edu.wpi.first.wpilibj.Victor;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;

import edu.wpi.first.wpilibj.SPI;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import edu.wpi.first.wpilibj.geometry.Pose2d;
import edu.wpi.first.wpilibj.geometry.Rotation2d;
//import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.wpilibj.kinematics.DifferentialDriveWheelSpeeds;

//import edu.wpi.first.wpilibj.ADXRS450_Gyro;
//import edu.wpi.first.wpilibj.Encoder;
//import edu.wpi.first.wpilibj.PWMSparkMax;
//import edu.wpi.first.wpilibj.SpeedControllerGroup;
//import edu.wpi.first.wpilibj.drive.DifferentialDrive;
//import edu.wpi.first.wpilibj.examples.ramsetecommand.Constants.DriveConstants;
//import edu.wpi.first.wpilibj2.command.SubsystemBase;


/**
 *
 */
public class DriveSubsystem extends SubsystemBase {

    //private RobotDrive robotDrive;
    public Encoder leftDriveEncoder;
    public Encoder rightDriveEncoder;
    //private AnalogGyro gyro;
    private AHRS ahrs;
    //private ADIS16470_IMU imu;
    

    private Rotation2d MyGyroAnlge;


    private WPI_TalonSRX leftDriveSpeedControl;
    private WPI_TalonSRX rightDriveSpeedControl;

    private WPI_VictorSPX leftDriveSpeedControlFollower;
    private WPI_VictorSPX rightDrriveSpeedControlFollower;

    private DifferentialDrive differentialDrive;

    enum DriveStyle {
        Tank,
        Arcade
    }

    private DriveStyle userDriveStyle = DriveStyle.Tank;

    private final DifferentialDriveOdometry m_odometry;

    /**
    *
    */
    public DriveSubsystem() {
        leftDriveEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        addChild("LeftDriveEncoder",leftDriveEncoder);
        //leftDriveEncoder.setDistancePerPulse(1.0);
        //leftDriveEncoder.setPIDSourceType(PIDSourceType.kRate);
        //leftDriveEncoder.setDistancePerPulse(19./2048.);  INCHES
        leftDriveEncoder.setDistancePerPulse(1./4096.);  //METER
        leftDriveEncoder.setMaxPeriod((.1));
        leftDriveEncoder.setMinRate(10);
        leftDriveEncoder.setSamplesToAverage(5);
        leftDriveEncoder.setReverseDirection(false);

        rightDriveEncoder = new Encoder(4, 5, false, EncodingType.k4X);
        addChild("RightDriveEncoder",rightDriveEncoder);
        //rightDriveEncoder.setDistancePerPulse(1.0);
        //rightDriveEncoder.setPIDSourceType(PIDSourceType.kRate);
        //rightDriveEncoder.setDistancePerPulse(19./2048.); //Inches
        rightDriveEncoder.setDistancePerPulse(1./4096.); //Inches
        rightDriveEncoder.setMaxPeriod((.1));
        rightDriveEncoder.setMinRate(10);
        rightDriveEncoder.setSamplesToAverage(5);
        rightDriveEncoder.setReverseDirection(true);


        //gyro = new AnalogGyro(0);
        //addChild("Gyro",gyro);
        //gyro.setSensitivity(0.007);
        //imu = new ADIS16470_IMU(IMUAxis.kY, SPI.Port.kOnboardCS0, ADIS16470CalibrationTime._4s);
        //imu = new ADIS16470_IMU();
        //addChild("IMU ",imu);

        leftDriveSpeedControl = new WPI_TalonSRX(21);
        addChild("leftDriveSpeedController",leftDriveSpeedControl);

        rightDriveSpeedControl = new WPI_TalonSRX(22);
        addChild("rightDriveSpeedControl",rightDriveSpeedControl);

        //Establish Drive followers
        leftDriveSpeedControlFollower = new WPI_VictorSPX(11);
        rightDrriveSpeedControlFollower = new WPI_VictorSPX(12);

        //Conigure follower Left and Right
        leftDriveSpeedControlFollower.follow(leftDriveSpeedControl);
        rightDrriveSpeedControlFollower.follow(rightDriveSpeedControl);

        //Configure Breaking Left and Right
        //leftDriveSpeedControl.setNeutralMode(NeutralMode.Coast);
        //rightDriveSpeedControl.setNeutralMode(NeutralMode.Coast);
        leftDriveSpeedControl.setNeutralMode(NeutralMode.Brake);
        rightDriveSpeedControl.setNeutralMode(NeutralMode.Brake);


        //Configure Full Speed take off ramp up Left and Right
        leftDriveSpeedControl.configOpenloopRamp(0.50);
        rightDriveSpeedControl.configOpenloopRamp(0.50);

        //Config Closed loop Left and Right
        //leftDriveSpeedControl.configClosedloopRamp(0.50);
        //rightDriveSpeedControl.configClosedloopRamp(0.50);

        //Config Voltage comp Left andRight
        leftDriveSpeedControl.enableVoltageCompensation(true);
        rightDriveSpeedControl.enableVoltageCompensation(true);

        leftDriveSpeedControl.configVoltageCompSaturation(11.5);
        rightDriveSpeedControl.configVoltageCompSaturation(11.5);

        differentialDrive = new DifferentialDrive(leftDriveSpeedControl, rightDriveSpeedControl);

        //NAVX Start
        ahrs = new AHRS(SPI.Port.kMXP);
        //ahrs.enableBoardlevelYawReset(true);


        addChild("NavXAHRS",ahrs);
        
        /* Display 6-axis Processed Angle Data                                      */
        SmartDashboard.putBoolean(  "IMU_Connected",        ahrs.isConnected());
        SmartDashboard.putBoolean(  "IMU_IsCalibrating",    ahrs.isCalibrating());
        SmartDashboard.putNumber(   "IMU_Yaw Z",              ahrs.getYaw());
        SmartDashboard.putNumber(   "IMU_Pitch Y",            ahrs.getPitch());
        SmartDashboard.putNumber(   "IMU_Roll X",             ahrs.getRoll());
        
        /* Display tilt-corrected, Magnetometer-based heading (requires             */
        /* magnetometer calibration to be useful)                                   */
        //SmartDashboard.putNumber(   "IMU_CompassHeading",   ahrs.getCompassHeading());
        
        /* Display 9-axis Heading (requires magnetometer calibration to be useful)  */
        //SmartDashboard.putNumber(   "IMU_FusedHeading",     ahrs.getFusedHeading());

        /* These functions are compatible w/the WPI Gyro Class, providing a simple  */
        /* path for upgrading from the Kit-of-Parts gyro to the navx-MXP            */
        //SmartDashboard.putNumber(   "IMU_TotalYaw",         ahrs.getAngle());
        //SmartDashboard.putNumber(   "IMU_YawRateDPS",       ahrs.getRate());

        /* Display Processed Acceleration Data (Linear Acceleration, Motion Detect) */
        //SmartDashboard.putNumber(   "IMU_Accel_X",          ahrs.getWorldLinearAccelX());
        //SmartDashboard.putNumber(   "IMU_Accel_Y",          ahrs.getWorldLinearAccelY());
        //SmartDashboard.putBoolean(  "IMU_IsMoving",         ahrs.isMoving());
        //SmartDashboard.putBoolean(  "IMU_IsRotating",       ahrs.isRotating());

        /* Display estimates of velocity/displacement.  Note that these values are  */
        /* not expected to be accurate enough for estimating robot position on a    */
        /* FIRST FRC Robotics Field, due to accelerometer noise and the compounding */
        /* of these errors due to single (velocity) integration and especially      */
        /* double (displacement) integration.                                       */
        //SmartDashboard.putNumber(   "Velocity_X",           ahrs.getVelocityX());
        //SmartDashboard.putNumber(   "Velocity_Y",           ahrs.getVelocityY());
        //SmartDashboard.putNumber(   "Displacement_X",       ahrs.getDisplacementX());
        //SmartDashboard.putNumber(   "Displacement_Y",       ahrs.getDisplacementY());
        
        /* Display Raw Gyro/Accelerometer/Magnetometer Values                       */
        /* NOTE:  These values are not normally necessary, but are made available   */
        /* for advanced users.  Before using this data, please consider whether     */
        /* the processed data (see above) will suit your needs.                     */
        //SmartDashboard.putNumber(   "RawGyro_X",            ahrs.getRawGyroX());
        //SmartDashboard.putNumber(   "RawGyro_Y",            ahrs.getRawGyroY());
        //SmartDashboard.putNumber(   "RawGyro_Z",            ahrs.getRawGyroZ());
        //SmartDashboard.putNumber(   "RawAccel_X",           ahrs.getRawAccelX());
        //SmartDashboard.putNumber(   "RawAccel_Y",           ahrs.getRawAccelY());
        //SmartDashboard.putNumber(   "RawAccel_Z",           ahrs.getRawAccelZ());
        //SmartDashboard.putNumber(   "RawMag_X",             ahrs.getRawMagX());
        //SmartDashboard.putNumber(   "RawMag_Y",             ahrs.getRawMagY());
        //SmartDashboard.putNumber(   "RawMag_Z",             ahrs.getRawMagZ());
        //SmartDashboard.putNumber(   "IMU_Temp_C",           ahrs.getTempC());
        
        /* Omnimount Yaw Axis Information                                           */
        /* For more info, see http://navx-mxp.kauailabs.com/installation/omnimount  */
        //AHRS.BoardYawAxis yaw_axis = ahrs.getBoardYawAxis();
        //SmartDashboard.putString(   "YawAxisDirection",     yaw_axis.up ? "Up" : "Down" );
        //SmartDashboard.putNumber(   "YawAxis",              yaw_axis.board_axis.getValue() );
        
        /* Sensor Board Information                                                 */
        //SmartDashboard.putString(   "FirmwareVersion",      ahrs.getFirmwareVersion());
        
        /* Quaternion Data                                                          */
        /* Quaternions are fascinating, and are the most compact representation of  */
        /* orientation data.  All of the Yaw, Pitch and Roll Values can be derived  */
        /* from the Quaternions.  If interested in motion processing, knowledge of  */
        /* Quaternions is highly recommended.                                       */
        //SmartDashboard.putNumber(   "QuaternionW",          ahrs.getQuaternionW());
        //SmartDashboard.putNumber(   "QuaternionX",          ahrs.getQuaternionX());
        //SmartDashboard.putNumber(   "QuaternionY",          ahrs.getQuaternionY());
        //SmartDashboard.putNumber(   "QuaternionZ",          ahrs.getQuaternionZ());
        
        /* Connectivity Debugging Support                                           */
        //SmartDashboard.putNumber(   "IMU_Byte_Count",       ahrs.getByteCount());
        //SmartDashboard.putNumber(   "IMU_Update_Count",     ahrs.getUpdateCount());
        //NAVX End

        // Odometry class for tracking robot pose

        leftDriveEncoder.reset();
        rightDriveEncoder.reset();
        //imu.reset();
        ahrs.reset();
        
        //m_odometry = new DifferentialDriveOdometry(ahrs.getRotation2d());
        m_odometry = new DifferentialDriveOdometry(Rotation2d.fromDegrees(getHeading()));
        //MyGyroAnlge = new Rotation2d
        //m_odometry = new DifferentialDriveOdometry(MyGyroAnlge);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        if (!RobotState.isAutonomous())
        {
            leftDriveSpeedControl.setInverted(false);
            rightDriveSpeedControl.setInverted(false);
            leftDriveSpeedControlFollower.setInverted(false);
            rightDrriveSpeedControlFollower.setInverted(false);
            
            if(userDriveStyle == DriveStyle.Tank) {
                differentialDrive.tankDrive(-RobotContainer.getInstance().getDriverJoystick().getRawAxis(5),
                                            -RobotContainer.getInstance().getDriverJoystick().getY());
                
            }
            else if (userDriveStyle == DriveStyle.Arcade) {
                differentialDrive.arcadeDrive(RobotContainer.getInstance().getShooterJoystick().getY(), 
                                              -RobotContainer.getInstance().getShooterJoystick().getX());

                //differentialDrive.arcadeDrive(RobotContainer.getInstance().getShooterJoystick().getY(), 
                //                                -RobotContainer.getInstance().getShooterJoystick().getZ());

                                              

            }
            differentialDrive.feed();

            // System.out.print(" X ");
            // //System.out.print(imu.getGyroInstantX());
            // System.out.print(ahrs.getRawGyroX());
            // System.out.print(" Y ");
            // //System.out.print(imu.getGyroInstantY());
            // System.out.print(ahrs.getRawGyroY());
            // System.out.print(" Z ");
            // //System.out.print(imu.getGyroInstantZ());
            // System.out.print(ahrs.getRawGyroZ());
            // System.out.print(" Angle ");
            // System.out.println(Rotation2d.fromDegrees(getHeading()));

            
        }

        // Update the odometry in the periodic block
        //m_odometry.update(ahrs.getRotation2d(), leftDriveEncoder.getDistance(), rightDriveEncoder.getDistance());

        //MyGyroAnlge = new Rotation2d(0);
        //m_odometry.update(MyGyroAnlge, leftDriveEncoder.getDistance(), rightDriveEncoder.getDistance());
        //m_odometry.update(imu.getRotation2d(), leftDriveEncoder.getDistance(), rightDriveEncoder.getDistance());
        m_odometry.update(Rotation2d.fromDegrees(getHeading()), leftDriveEncoder.getDistance(), rightDriveEncoder.getDistance());

        //System.out.print(" Left ");
        //System.out.print(leftDriveEncoder.getDistance());
        //System.out.print(" Right ");
        //System.out.print(rightDriveEncoder.getDistance());
        //System.out.print(" X ");
        //System.out.print(imu.getGyroInstantX());
        //System.out.print(" Y ");
        //System.out.println(imu.getGyroInstantY());


    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void toggleDriveStyle() {
        System.out.println("DRIVE TOGGLE");
        if (userDriveStyle == DriveStyle.Tank) {
            userDriveStyle = DriveStyle.Arcade;
        } else {
            userDriveStyle = DriveStyle.Tank;
        }

    }

    public void ZeroEncoders() {
        leftDriveEncoder.reset();
        rightDriveEncoder.reset();
        ahrs.reset();
        //imu.reset();
    }

    public void TankDriveControl(double leftSpeed, double rightSpeed) {
        differentialDrive.tankDrive(leftSpeed, rightSpeed);
    }

    public double getGyroAngle() {
        //return imu.getAngle();
        return ahrs.getAngle();
    }
    public double getAngleRate() {
        //return imu.getRate();
        return ahrs.getRate();
    }
    
    /**
   * Returns the currently-estimated pose of the robot.
   *
   * @return The pose.
   */
    public Pose2d getPose() {
        return m_odometry.getPoseMeters();
    }

    /**
     * Returns the current wheel speeds of the robot.
     *
     * @return The current wheel speeds.
     */
    public DifferentialDriveWheelSpeeds getWheelSpeeds() {
        return new DifferentialDriveWheelSpeeds(leftDriveEncoder.getRate(), rightDriveEncoder.getRate());
    }

    /**
     * Resets the odometry to the specified pose.
     *
     * @param pose The pose to which to set the odometry.
     */
    public void resetOdometry(Pose2d pose) {
        resetEncoders();
        m_odometry.resetPosition(pose, ahrs.getRotation2d());
        //m_odometry.resetPosition(pose, imu.getRotation2d());

    }

    /**
     * Drives the robot using arcade controls.
     *
     * @param fwd the commanded forward movement
     * @param rot the commanded rotation
     */
    public void arcadeDrive(double fwd, double rot) {
        differentialDrive.arcadeDrive(fwd, rot);
    }

    /**
     * Controls the left and right sides of the drive directly with voltages.
     *
     * @param leftVolts the commanded left output
     * @param rightVolts the commanded right output
     */
    public void tankDriveVolts(double leftVolts, double rightVolts) {
        leftDriveSpeedControl.configVoltageCompSaturation(11.0);
        rightDriveSpeedControl.configVoltageCompSaturation(11.0);

        leftDriveSpeedControl.enableVoltageCompensation(false);
        rightDriveSpeedControl.enableVoltageCompensation(false);

        leftDriveSpeedControl.setInverted(true);
        rightDriveSpeedControl.setInverted(false);
        leftDriveSpeedControlFollower.setInverted(true);
        rightDrriveSpeedControlFollower.setInverted(false);

        leftDriveEncoder.setReverseDirection(true);
        rightDriveEncoder.setReverseDirection(false);

        leftDriveSpeedControl.setVoltage(leftVolts);
        rightDriveSpeedControl.setVoltage(rightVolts);
        differentialDrive.feed();
        
        System.out.print(" X ");
        System.out.print(ahrs.getRawGyroX());
        System.out.print(" Y ");
        System.out.print(ahrs.getRawGyroY());
        System.out.print(" Z ");
        System.out.print(ahrs.getRawGyroZ());
        System.out.print(" Angle ");
        System.out.print(Rotation2d.fromDegrees(getHeading()));
        System.out.print(" Left ");
        System.out.print(leftVolts);
        System.out.print(" Right ");
        System.out.println(rightVolts);

    }

    /** Resets the drive encoders to currently read a position of 0. */
    public void resetEncoders() {
        leftDriveEncoder.reset();
        rightDriveEncoder.reset();
        ahrs.reset();
        //imu.reset();
    }

    /**
     * Gets the average distance of the two encoders.
     *
     * @return the average of the two encoder readings
     */
    public double getAverageEncoderDistance() {
        return (leftDriveEncoder.getDistance() + rightDriveEncoder.getDistance()) / 2.0;
    }

    /**
     * Gets the left drive encoder.
     *
     * @return the left drive encoder
     */
    public Encoder getLeftEncoder() {
        return leftDriveEncoder;
    }

    /**
     * Gets the right drive encoder.
     *
     * @return the right drive encoder
     */
    public Encoder getRightEncoder() {
        return rightDriveEncoder;
    }

    /**
     * Sets the max output of the drive. Useful for scaling the drive to drive more slowly.
     *
     * @param maxOutput the maximum output to which the drive will be constrained
     */
    public void setMaxOutput(double maxOutput) {
        differentialDrive.setMaxOutput(maxOutput);
    }

    /**
     * Returns the heading of the robot.
     *
     * @return the robot's heading in degrees, from -180 to 180
     */
    public double getHeading() {
        return (ahrs.getRotation2d().getDegrees());
        //return imu.getRotation2d().getDegrees();
    }

    /**
     * Returns the turn rate of the robot.
     *
     * @return The turn rate of the robot, in degrees per second
     */
    public double getTurnRate() {
        return ahrs.getRate();
        //return imu.getRate();
   }

}
