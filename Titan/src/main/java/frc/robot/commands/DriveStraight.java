// RobotBuilder Version: 3.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package frc.robot.commands;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.DriveSubsystem;

/**
 *
 */
public class DriveStraight extends CommandBase {

    private final DriveSubsystem m_driveSubsystem;

    private final double kP = .02;
    private double Speed = 0.7;
    private double distanceToTravel;
   
    enum Direction {
        Forward,
        Reverse
    }
    private Boolean driveDirection;

    public DriveStraight(DriveSubsystem subsystem, double traveldistance, boolean DriveForward) {

        m_driveSubsystem = subsystem;
        addRequirements(m_driveSubsystem);

        distanceToTravel = traveldistance;
        driveDirection = DriveForward;

        
    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
        m_driveSubsystem.ZeroEncoders();
        
    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        // Assuming no wheel slip, the difference in encoder distances is proportional to the heading error
        double leftValue =  m_driveSubsystem.leftDriveEncoder.getDistance();
        double rightValue =  m_driveSubsystem.rightDriveEncoder.getDistance();
        double error = leftValue - rightValue;
        double Correction = (kP * error);
        // Drives forward continuously at half speed, using the encoders to stabilize the heading
        //What if moving backwards?

        if(driveDirection) {
            m_driveSubsystem.TankDriveControl(Speed + Correction, Speed - Correction);
        }else {
            m_driveSubsystem.TankDriveControl(-1*(Speed + Correction), -1*(Speed - Correction));
        }

        System.out.print("Final Left Speed " + Speed + Correction);
        System.out.println("   Correction " + Correction);

    }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {

    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
        //What if moving backwards
        if (Math.abs(m_driveSubsystem.leftDriveEncoder.getDistance()) >= distanceToTravel || 
                Math.abs(m_driveSubsystem.rightDriveEncoder.getDistance()) >= distanceToTravel) {
            return true;
        }
        else {
            return false;
        }
        
    }

    @Override
    public boolean runsWhenDisabled() {
        return false;

    }
}
